#version 460 core

layout(local_size_x = 16, local_size_y = 16) in;

layout(rgba8ui, binding = 0) uniform readonly uimage2D stateIn;
layout(rgba8ui, binding = 1) uniform writeonly uimage2D stateOut;

struct ElementData {
    vec4 color;
    int type; // 0:Static, 1:Granular, 2:Liquid, 3:Gas
    float density;
    float viscosity;
    float probability; // burn chance
    int flammability;
    int glow;
    int maxLife;
    int gemstone;
    float lightRadius;
    float lightIntensity;
    float ior;
    int _pad;
};

layout(std430, binding = 2) buffer ElementRegistry {
    ElementData elements[];
};

uniform vec2  worldSize;
uniform float time;
uniform uint  frameCount;

// Type constants
const int TYPE_STATIC   = 0;
const int TYPE_GRANULAR = 1;
const int TYPE_LIQUID   = 2;
const int TYPE_GAS      = 3;

// ─── Helpers ───

bool inBounds(ivec2 p) {
    return (p.x >= 0 && p.x < int(worldSize.x) &&
            p.y >= 0 && p.y < int(worldSize.y));
}

float random01(ivec2 pos) {
    return fract(sin(dot(vec2(pos) + time, vec2(12.9898, 78.233))) * 43758.5453);
}

// Second independent hash for when we need two uncorrelated randoms at the same pos
float random01b(ivec2 pos) {
    return fract(sin(dot(vec2(pos) + time * 1.7, vec2(39.346, 11.135))) * 23421.6312);
}

uint hashU32(uint x) {
    x ^= x >> 16;
    x *= 2246822519u;
    x ^= x >> 13;
    x *= 3266489917u;
    x ^= x >> 16;
    return x;
}

uint hash2u(uvec2 v) {
    return hashU32(v.x ^ (v.y + 0x9e3779b9u + (v.x<<6) + (v.x>>2)));
}

// Hash with extra salt for independent random streams
uint hash3u(uvec2 v, uint salt) {
    return hashU32(v.x ^ (v.y + salt + 0x9e3779b9u + (v.x<<6) + (v.x>>2)));
}

uvec4 getState(ivec2 pos) {
    if (!inBounds(pos)) {
        return uvec4(255u, 0u, 0u, 0u); // solid boundary sentinel
    }
    return imageLoad(stateIn, pos);
}

uint getElement(ivec2 pos) { return getState(pos).r; }
uint getLife(ivec2 pos) { return getState(pos).g; }

// ─── Type checks ───

bool isStatic(uint id) {
    return id < MAX_ELEMENTS && elements[id].type == TYPE_STATIC;
}

bool isGranular(uint id) {
    return id < MAX_ELEMENTS && elements[id].type == TYPE_GRANULAR;
}

bool isLiquid(uint id) {
    return id < MAX_ELEMENTS && elements[id].type == TYPE_LIQUID;
}

bool isGas(uint id) {
    return id < MAX_ELEMENTS && elements[id].type == TYPE_GAS;
}

bool isEmpty(uint id) {
    return id == EMPTY;
}

bool isImmobile(uint id) {
    if (id >= MAX_ELEMENTS) return true;
    return elements[id].type == TYPE_STATIC;
}

bool isFlammable(uint id) {
    return id < MAX_ELEMENTS && elements[id].flammability == 1;
}

bool isGlowing(uint id) {
    return id < MAX_ELEMENTS && elements[id].glow == 1;
}

bool hasLife(uint id) {
    return id < MAX_ELEMENTS && elements[id].maxLife > 0;
}

// ─── Movement Logic ───

bool canDisplace(uint mover, uint target) {
    if (target == EMPTY) return true;
    if (mover == target) return false;
    if (mover >= MAX_ELEMENTS || target >= MAX_ELEMENTS) return false;

    float dMover = elements[mover].density;
    float dTarget = elements[target].density;

    // Fire destroys smoke (both are gases, fire is special)
    if (mover == FIRE && target == SMOKE) return true;

    // Heavier things displace lighter fluids/gases
    if (dMover > dTarget && (isLiquid(target) || isGas(target))) return true;

    // Lava/Fire burns flammable things
    if ((mover == LAVA || mover == FIRE) && isFlammable(target)) return true;

    return false;
}

ivec2 desiredDest(ivec2 src, uint elem) {
    if (isStatic(elem)) return src;

    int type = elements[elem].type;
    ivec2 down  = src + ivec2(0, -1);
    ivec2 downL = src + ivec2(-1, -1);
    ivec2 downR = src + ivec2(1, -1);
    ivec2 left  = src + ivec2(-1, 0);
    ivec2 right = src + ivec2(1, 0);
    ivec2 up    = src + ivec2(0, 1);
    ivec2 upL   = src + ivec2(-1, 1);
    ivec2 upR   = src + ivec2(1, 1);

    bool leftFirst = (hash2u(uvec2(src) ^ uvec2(frameCount)) & 1u) == 0u;

    // ─── Light element drift ───
    if (type == TYPE_GRANULAR) {
        float density = elements[elem].density;

        // Only apply drift to elements that are actively falling (empty below)
        if (canDisplace(elem, getElement(down))) {
            float driftChance = clamp(3.0 / max(density, 0.5), 0.02, 0.5);

            float roll = float(hash3u(uvec2(src), frameCount) & 0xFFFFu) / 65535.0;
            if (roll < driftChance) {
                if (leftFirst) {
                    if (canDisplace(elem, getElement(downL))) return downL;
                    if (canDisplace(elem, getElement(downR))) return downR;
                } else {
                    if (canDisplace(elem, getElement(downR))) return downR;
                    if (canDisplace(elem, getElement(downL))) return downL;
                }
            }
            // Normal straight-down fall
            return down;
        }
        // Can't fall straight — try diagonals normally
        if (leftFirst) {
            if (canDisplace(elem, getElement(downL))) return downL;
            if (canDisplace(elem, getElement(downR))) return downR;
        } else {
            if (canDisplace(elem, getElement(downR))) return downR;
            if (canDisplace(elem, getElement(downL))) return downL;
        }
    }
    // LIQUID
    else if (type == TYPE_LIQUID) {
        if (canDisplace(elem, getElement(down))) return down;

        // Viscosity check - higher viscosity = more likely to stay put
        if (random01(src) < elements[elem].viscosity) return src;

        if (leftFirst) {
            if (canDisplace(elem, getElement(downL))) return downL;
            if (canDisplace(elem, getElement(downR))) return downR;
            if (canDisplace(elem, getElement(left))) return left;
            if (canDisplace(elem, getElement(right))) return right;
        } else {
            if (canDisplace(elem, getElement(downR))) return downR;
            if (canDisplace(elem, getElement(downL))) return downL;
            if (canDisplace(elem, getElement(right))) return right;
            if (canDisplace(elem, getElement(left))) return left;
        }
    }
    // GAS
    else if (type == TYPE_GAS) {
        if (getElement(up) == EMPTY) return up;
        if (leftFirst) {
            if (getElement(upL) == EMPTY) return upL;
            if (getElement(upR) == EMPTY) return upR;
            if (getElement(left) == EMPTY) return left;
            if (getElement(right) == EMPTY) return right;
        } else {
            if (getElement(upR) == EMPTY) return upR;
            if (getElement(upL) == EMPTY) return upL;
            if (getElement(right) == EMPTY) return right;
            if (getElement(left) == EMPTY) return left;
        }
    }

    return src;
}

bool sourceProposesTo(ivec2 src, ivec2 dest) {
    if (!inBounds(src)) return false;
    uint e = getElement(src);
    if (e == EMPTY || isImmobile(e)) return false;
    ivec2 d = desiredDest(src, e);
    return (d == dest && canDisplace(e, getElement(dest)));
}

ivec2 pickWinnerForDest(ivec2 dest) {
    ivec2 best = ivec2(999999);
    uint bestScore = 0u;
    bool found = false;

    // Check neighbors
    for (int oy = -1; oy <= 1; ++oy) {
        for (int ox = -1; ox <= 1; ++ox) {
            if (ox == 0 && oy == 0) continue;
            ivec2 src = dest + ivec2(ox, oy);
            if (sourceProposesTo(src, dest)) {
                uint score = hash2u(uvec2(src) ^ uvec2(dest) ^ uvec2(frameCount));
                if (!found || score > bestScore) {
                    found = true;
                    bestScore = score;
                    best = src;
                }
            }
        }
    }
    return found ? best : ivec2(999999);
}

// ─── Sapling Tree Growth (Pull-Based) ───
const int MAX_TREE_HEIGHT = 25;
const int MAX_TREE_SPREAD = 8;

bool isTouchingSoil(ivec2 pos) {
    for (int dy = -1; dy <= 1; dy++) {
        for (int dx = -1; dx <= 1; dx++) {
            if (dx == 0 && dy == 0) continue;
            ivec2 np = pos + ivec2(dx, dy);
            if (inBounds(np)) {
                uint e = getElement(np);
                if (e == DIRT || e == GRASS) return true;
            }
        }
    }
    return false;
}

uint treeElementAt(ivec2 saplingPos, ivec2 queryPos, uint targetHeight, uint growthStep) {
    int rx = queryPos.x - saplingPos.x;
    int ry = queryPos.y - saplingPos.y;

    if (ry < 0) return EMPTY;

    uint treeSeed = hash2u(uvec2(saplingPos));

    // Trunk
    if (rx == 0 && ry >= 1 && uint(ry) <= targetHeight) {
        if (uint(ry) <= growthStep) {
            return WOOD;
        }
        return EMPTY;
    }

    // Branches
    uint branchStartY = 4u;
    for (uint trunkY = branchStartY; trunkY <= targetHeight && trunkY <= growthStep; trunkY++) {
        uint branchSeed = hash3u(uvec2(saplingPos), trunkY * 37u);
        float branchRoll = float(branchSeed & 0xFFFFu) / 65535.0;

        float heightRatio = float(trunkY) / float(targetHeight);
        float branchChance = 0.0;
        if (heightRatio < 0.85) {
            float midFactor = 1.0 - abs(heightRatio - 0.55) * 2.5;
            branchChance = clamp(midFactor * 0.7, 0.15, 0.65);
        }

        if (branchRoll >= branchChance) continue;

        bool goLeft = (branchSeed & 0x10000u) != 0u;
        int dir = goLeft ? -1 : 1;

        float midBonus = 1.0 - abs(heightRatio - 0.5) * 2.0;
        uint maxLen = uint(clamp(midBonus * 4.0 + 2.0, 2.0, 5.0));
        uint branchLen = (hash3u(uvec2(saplingPos), trunkY * 53u + 7u) % maxLen) + 1u;

        for (uint b = 1u; b <= branchLen; b++) {
            ivec2 bp = ivec2(saplingPos.x + int(b) * dir, saplingPos.y + int(trunkY));
            if (b > 2u) bp.y += 1;

            if (queryPos == bp) {
                return WOOD;
            }

            if (b >= branchLen - 1u) {
                int ldx = queryPos.x - bp.x;
                int ldy = queryPos.y - bp.y;
                if (abs(ldx) <= 2 && ldy >= -1 && ldy <= 2) {
                    if (abs(ldx) + abs(ldy) <= 3) {
                        float leafRoll = float(hash3u(uvec2(queryPos), trunkY * 71u + 200u) & 0xFFFFu) / 65535.0;
                        if (leafRoll < 0.55) {
                            return PLANT;
                        }
                    }
                }
            }
        }
    }

    // Top canopy
    if (growthStep >= targetHeight - 2u) {
        int canopyRadius = int(targetHeight) / 4 + 2;
        ivec2 canopyCenter = ivec2(saplingPos.x, saplingPos.y + int(targetHeight));
        int cdx = queryPos.x - canopyCenter.x;
        int cdy = queryPos.y - canopyCenter.y;

        if (abs(cdx) <= canopyRadius && cdy >= -1 && cdy <= canopyRadius + 1) {
            float dist = sqrt(float(cdx*cdx + cdy*cdy));
            if (dist <= float(canopyRadius) + 0.5) {
                float leafRoll = float(hash3u(uvec2(queryPos), targetHeight * 97u + 500u) & 0xFFFFu) / 65535.0;
                float noise = float(hash3u(uvec2(queryPos), 999u) & 0xFFu) / 255.0;
                if (leafRoll < 0.55 && noise > 0.25) {
                    if (!(cdx == 0 && cdy <= 0)) {
                        return PLANT;
                    }
                }
            }
        }
    }

    return EMPTY;
}

uint checkTreeClaim(ivec2 pos) {
    for (int dy = 1; dy <= MAX_TREE_HEIGHT; dy++) {
        ivec2 candidatePos = pos + ivec2(0, -dy);
        if (!inBounds(candidatePos)) break;

        uvec4 candidateState = getState(candidatePos);
        if (candidateState.r != SAPLING) continue;

        uint growthStep = candidateState.b;
        if (growthStep == 0u) continue;

        uint targetHeight = candidateState.g;

        if (uint(dy) <= growthStep && uint(dy) <= targetHeight) {
            return WOOD;
        }

        uint result = treeElementAt(candidatePos, pos, targetHeight, growthStep);
        if (result != EMPTY) return result;
    }

    for (int dx = -MAX_TREE_SPREAD; dx <= MAX_TREE_SPREAD; dx++) {
        if (dx == 0) continue;
        for (int dy = 0; dy <= MAX_TREE_HEIGHT + 3; dy++) {
            ivec2 candidatePos = pos + ivec2(dx, -dy);
            if (!inBounds(candidatePos)) continue;

            uvec4 candidateState = getState(candidatePos);
            if (candidateState.r != SAPLING) continue;

            uint growthStep = candidateState.b;
            if (growthStep == 0u) continue;

            uint targetHeight = candidateState.g;
            uint result = treeElementAt(candidatePos, pos, targetHeight, growthStep);
            if (result != EMPTY) return result;
        }
    }

    return EMPTY;
}

void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    if (!inBounds(pos)) return;

    uvec4 cur = getState(pos);
    uint elem = cur.r;
    uint life = cur.g;

    // Boundary sentinel check
    if (elem >= MAX_ELEMENTS) {
        imageStore(stateOut, pos, cur);
        return;
    }

    // ═══════════════════════════════════════
    // REACTION LOGIC
    // ═══════════════════════════════════════

    // Water + Lava interaction
    if (elem == WATER) {
        bool touchingLava = false;
        for (int dy = -1; dy <= 1; dy++) {
            for (int dx = -1; dx <= 1; dx++) {
                if (getElement(pos + ivec2(dx, dy)) == LAVA) {
                    touchingLava = true;
                }
            }
        }
        if (touchingLava) {
            imageStore(stateOut, pos, uvec4(SMOKE, 200u, 0, 0));
            return;
        }
    }
    if (elem == LAVA) {
        bool touchingWater = false;
        for (int dy = -1; dy <= 1; dy++) {
            for (int dx = -1; dx <= 1; dx++) {
                if (getElement(pos + ivec2(dx, dy)) == WATER) {
                    touchingWater = true;
                }
            }
        }
        if (touchingWater) {
            imageStore(stateOut, pos, uvec4(OBSIDIAN, 0u, 0, 0));
            return;
        }
    }

    // ═══════════════════════════════════════
    // SMOKE DECAY (FIX: guaranteed death + color variation via life)
    // Smoke uses life for opacity/color. Decays with randomness.
    // When life reaches 0, ALWAYS becomes EMPTY.
    // ═══════════════════════════════════════
    if (elem == SMOKE) {
        if (life == 0u) {
            // Dead smoke -> always disappear
            imageStore(stateOut, pos, uvec4(EMPTY, 0u, 0u, 0u));
            return;
        }
        // Variable decay rate: 2-6 per step, ensures smoke always dies
        uint baseDecay = 3u;
        uint randDecay = hash3u(uvec2(pos), frameCount) % 5u; // 0..4
        uint totalDecay = baseDecay + randDecay; // 3..7

        if (life <= totalDecay) {
            imageStore(stateOut, pos, uvec4(EMPTY, 0u, 0u, 0u));
            return;
        }
        cur.g = life - totalDecay;
        // Don't return - let smoke continue to movement below
    }

    // Generic Life Decay (for non-smoke elements with life: Fire etc.)
    if (elem != SMOKE && hasLife(elem) && life > 0u) {
        uint decayRate = 4u;
        if (life <= decayRate) {
            // Fire -> Smoke on death. Grass -> Dirt on death.
            uint deathElem;
            uint deathLife;
            if (elem == FIRE) {
                deathElem = SMOKE;
                deathLife = 180u + (hash3u(uvec2(pos), frameCount) % 40u); // 180..219 varied
            } else {
                deathElem = EMPTY;
                deathLife = 0u;
            }
            imageStore(stateOut, pos, uvec4(deathElem, deathLife, 0, 0));
            return;
        }
        cur.g = life - decayRate;
    }

    // ═══════════════════════════════════════
    // FLAMMABILITY (FIX: Grass burns -> Dirt, not Empty)
    // ═══════════════════════════════════════
    if (isFlammable(elem)) {
        bool touchingFire = false;
        for(int dy = -1; dy <= 1; dy++) {
            for(int dx = -1; dx <= 1; dx++) {
                uint n = getElement(pos + ivec2(dx, dy));
                if (n == FIRE || n == LAVA) touchingFire = true;
            }
        }
        if (touchingFire && random01(pos) < elements[elem].probability) {
            // Grass and Dirt-like elements burn back to dirt instead of disappearing
            if (elem == GRASS) {
                imageStore(stateOut, pos, uvec4(DIRT, 0u, 0u, 0u));
            } else {
                imageStore(stateOut, pos, uvec4(FIRE, 255u, 0, 0));
            }
            return;
        }
    }

    // ═══════════════════════════════════════
    // SEED -> GRASS Logic
    // ═══════════════════════════════════════
    if (elem == SEED) {
        ivec2 below = pos + ivec2(0, -1);
        bool resting = !inBounds(below) || !canDisplace(elem, getElement(below));

        if (resting) {
            bool touchingSoil = false;
            for (int dy = -1; dy <= 1; dy++) {
                for (int dx = -1; dx <= 1; dx++) {
                    if (dx == 0 && dy == 0) continue;
                    ivec2 np = pos + ivec2(dx, dy);
                    if (inBounds(np)) {
                        uint ne = getElement(np);
                        if (ne == DIRT || ne == GRASS) {
                            touchingSoil = true;
                        }
                    }
                }
            }
            if (touchingSoil) {
                imageStore(stateOut, pos, uvec4(GRASS, 255u, 0, 0));
                return;
            }
        }
    }

    // ═══════════════════════════════════════
    // GRASS Spreading
    // ═══════════════════════════════════════
    if (elem == DIRT) {
        ivec2 dirs[8] = ivec2[8](
            ivec2(1,0), ivec2(-1,0), ivec2(0,-1), ivec2(0,1),
            ivec2(1,1), ivec2(-1,1), ivec2(1,-1), ivec2(-1,-1)
        );

        int startIdx = int(random01b(pos) * 8.0);

        for (int i = 0; i < 8; i++) {
            int idx = (startIdx + i) % 8;
            ivec2 neighborPos = pos + dirs[idx];

            if (inBounds(neighborPos)) {
                uvec4 nState = getState(neighborPos);
                uint nElem = nState.r;
                uint nLife = nState.g;

                if (nElem == GRASS && nLife > 30u) {
                    ivec2 belowNeighbor = neighborPos + ivec2(0, -1);
                    bool isSettled = !inBounds(belowNeighbor) || !canDisplace(GRASS, getElement(belowNeighbor));

                    if (isSettled) {
                        float spreadChance = (float(nLife) / 255.0) * 0.10;
                        if (random01(pos) < spreadChance) {
                            uint newLife = nLife - 20u;
                            if (newLife < 30u) newLife = 30u;

                            imageStore(stateOut, pos, uvec4(GRASS, newLife, 0, 0));
                            return;
                        }
                    }
                }
            }
        }
    }

    // ═══════════════════════════════════════
    // SAPLING State Machine
    // ═══════════════════════════════════════
    if (elem == SAPLING) {
        uint growthStep = cur.b;
        uint targetHeight = cur.g;

        if (growthStep == 0u) {
            if (isTouchingSoil(pos)) {
                uint treeHeight = hash2u(uvec2(pos)) % 14u + 12u;
                imageStore(stateOut, pos, uvec4(SAPLING, treeHeight, 1u, 0u));
                return;
            }
        }
        else {
            if (growthStep >= targetHeight) {
                imageStore(stateOut, pos, uvec4(WOOD, 0u, 0u, 0u));
                return;
            } else {
                imageStore(stateOut, pos, uvec4(SAPLING, targetHeight, growthStep + 1u, 0u));
                return;
            }
        }
    }

    // ═══════════════════════════════════════
    // TREE CLAIM CHECK (Pull-based)
    // ═══════════════════════════════════════
    if (elem == EMPTY) {
        uint claimed = checkTreeClaim(pos);
        if (claimed != EMPTY) {
            imageStore(stateOut, pos, uvec4(claimed, 0u, 0u, 0u));
            return;
        }
    }

    // ═══════════════════════════════════════
    // MOVEMENT
    // ═══════════════════════════════════════

    // If someone wins moving into us, we get overwritten
    ivec2 winner = pickWinnerForDest(pos);
    if (winner.x != 999999) {
        uvec4 winState = getState(winner);
        imageStore(stateOut, pos, winState);
        return;
    }

    // Otherwise, try to move
    if (!isEmpty(elem) && !isImmobile(elem)) {
        ivec2 dest = desiredDest(pos, elem);
        if (dest != pos && canDisplace(elem, getElement(dest))) {
            ivec2 w = pickWinnerForDest(dest);
            if (w == pos) {
                // We moved. Get what we displaced (swap)
                uvec4 displaced = getState(dest);
                imageStore(stateOut, pos, displaced);
                return;
            }
        }
    }

    // If nothing happened, write back (possibly modified) state
    imageStore(stateOut, pos, cur);
}