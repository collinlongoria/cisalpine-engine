#version 460 core

layout(local_size_x = 16, local_size_y = 16) in;

layout(rgba8ui, binding = 0) uniform readonly uimage2D stateIn;
layout(rgba8ui, binding = 1) uniform writeonly uimage2D stateOut;

struct ElementData {
    vec4 color;
    int type; // 0:Static, 1:Granular, 2:Liquid, 3:Gas
    float density;
    float viscosity;
    float probability; // burn chance
    int flammability;
    int glow;
    int maxLife;
    int _pad;
};

layout(std430, binding = 2) buffer ElementRegistry {
    ElementData elements[];
};

uniform vec2  worldSize;
uniform float time;
uniform uint  frameCount;

// Type constants
const int TYPE_STATIC   = 0;
const int TYPE_GRANULAR = 1;
const int TYPE_LIQUID   = 2;
const int TYPE_GAS      = 3;

// Helpers

bool inBounds(ivec2 p) {
    return (p.x >= 0 && p.x < int(worldSize.x) &&
            p.y >= 0 && p.y < int(worldSize.y));
}

float random01(ivec2 pos) {
    return fract(sin(dot(vec2(pos) + time, vec2(12.9898, 78.233))) * 43758.5453);
}

uint hashU32(uint x) {
    x ^= x >> 16;
    x *= 2246822519u;
    x ^= x >> 13;
    x *= 3266489917u;
    x ^= x >> 16;
    return x;
}

uint hash2u(uvec2 v) {
    return hashU32(v.x ^ (v.y + 0x9e3779b9u + (v.x<<6) + (v.x>>2)));
}

uvec4 getState(ivec2 pos) {
    if (!inBounds(pos)) {
        return uvec4(255u, 0u, 0u, 0u); // solid boundary sentinel
    }
    return imageLoad(stateIn, pos);
}

uint getElement(ivec2 pos) { return getState(pos).r; }
uint getLife(ivec2 pos) { return getState(pos).g; }

// Type checks

bool isStatic(uint id) {
    return id < MAX_ELEMENTS && elements[id].type == TYPE_STATIC;
}

bool isGranular(uint id) {
    return id < MAX_ELEMENTS && elements[id].type == TYPE_GRANULAR;
}

bool isLiquid(uint id) {
    return id < MAX_ELEMENTS && elements[id].type == TYPE_LIQUID;
}

bool isGas(uint id) {
    return id < MAX_ELEMENTS && elements[id].type == TYPE_GAS;
}

bool isEmpty(uint id) {
    return id == EMPTY;
}

bool isImmobile(uint id) {
    if (id >= MAX_ELEMENTS) return true;
    return elements[id].type == TYPE_STATIC;
}

bool isFlammable(uint id) {
    return id < MAX_ELEMENTS && elements[id].flammability == 1;
}

bool isGlowing(uint id) {
    return id < MAX_ELEMENTS && elements[id].glow == 1;
}

bool hasLife(uint id) {
    return id < MAX_ELEMENTS && elements[id].maxLife > 0;
}

// Movement Logic

bool canDisplace(uint mover, uint target) {
    if (target == EMPTY) return true;
    if (mover == target) return false;
    if (mover >= MAX_ELEMENTS || target >= MAX_ELEMENTS) return false;

    float dMover = elements[mover].density;
    float dTarget = elements[target].density;

    // Fire destroys smoke (both are gases, fire is special)
    if (mover == FIRE && target == SMOKE) return true;

    // Heavier things displace lighter fluids/gases
    if (dMover > dTarget && (isLiquid(target) || isGas(target))) return true;

    // Lava/Fire burns flammable things
    if ((mover == LAVA || mover == FIRE) && isFlammable(target)) return true;

    return false;
}

ivec2 desiredDest(ivec2 src, uint elem) {
    if (isStatic(elem)) return src;

    int type = elements[elem].type;
    ivec2 down  = src + ivec2(0, -1);
    ivec2 downL = src + ivec2(-1, -1);
    ivec2 downR = src + ivec2(1, -1);
    ivec2 left  = src + ivec2(-1, 0);
    ivec2 right = src + ivec2(1, 0);
    ivec2 up    = src + ivec2(0, 1);
    ivec2 upL   = src + ivec2(-1, 1);
    ivec2 upR   = src + ivec2(1, 1);

    bool leftFirst = (hash2u(uvec2(src) ^ uvec2(frameCount)) & 1u) == 0u;

    // GRANULAR
    if (type == TYPE_GRANULAR) {
        if (canDisplace(elem, getElement(down))) return down;
        if (leftFirst) {
            if (canDisplace(elem, getElement(downL))) return downL;
            if (canDisplace(elem, getElement(downR))) return downR;
        } else {
            if (canDisplace(elem, getElement(downR))) return downR;
            if (canDisplace(elem, getElement(downL))) return downL;
        }
    }
    // LIQUID
    else if (type == TYPE_LIQUID) {
        if (canDisplace(elem, getElement(down))) return down;

        // Viscosity check - higher viscosity = more likely to stay put
        if (random01(src) < elements[elem].viscosity) return src;

        if (leftFirst) {
            if (canDisplace(elem, getElement(downL))) return downL;
            if (canDisplace(elem, getElement(downR))) return downR;
            if (canDisplace(elem, getElement(left))) return left;
            if (canDisplace(elem, getElement(right))) return right;
        } else {
            if (canDisplace(elem, getElement(downR))) return downR;
            if (canDisplace(elem, getElement(downL))) return downL;
            if (canDisplace(elem, getElement(right))) return right;
            if (canDisplace(elem, getElement(left))) return left;
        }
    }
    // GAS
    else if (type == TYPE_GAS) {
        if (getElement(up) == EMPTY) return up;
        if (leftFirst) {
            if (getElement(upL) == EMPTY) return upL;
            if (getElement(upR) == EMPTY) return upR;
            if (getElement(left) == EMPTY) return left;
            if (getElement(right) == EMPTY) return right;
        } else {
            if (getElement(upR) == EMPTY) return upR;
            if (getElement(upL) == EMPTY) return upL;
            if (getElement(right) == EMPTY) return right;
            if (getElement(left) == EMPTY) return left;
        }
    }

    return src;
}

bool sourceProposesTo(ivec2 src, ivec2 dest) {
    if (!inBounds(src)) return false;
    uint e = getElement(src);
    if (e == EMPTY || isImmobile(e)) return false;
    ivec2 d = desiredDest(src, e);
    return (d == dest && canDisplace(e, getElement(dest)));
}

ivec2 pickWinnerForDest(ivec2 dest) {
    ivec2 best = ivec2(999999);
    uint bestScore = 0u;
    bool found = false;

    // Check neighbors
    for (int oy = -1; oy <= 1; ++oy) {
        for (int ox = -1; ox <= 1; ++ox) {
            if (ox == 0 && oy == 0) continue;
            ivec2 src = dest + ivec2(ox, oy);
            if (sourceProposesTo(src, dest)) {
                uint score = hash2u(uvec2(src) ^ uvec2(dest) ^ uvec2(frameCount));
                if (!found || score > bestScore) {
                    found = true;
                    bestScore = score;
                    best = src;
                }
            }
        }
    }
    return found ? best : ivec2(999999);
}

void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    if (!inBounds(pos)) return;

    uvec4 cur = getState(pos);
    uint elem = cur.r;
    uint life = cur.g;

    // Boundary sentinel check
    if (elem >= MAX_ELEMENTS) {
        imageStore(stateOut, pos, cur);
        return;
    }

    // REACTION LOGIC

    // Water + Lava interaction
    // Water touching lava -> this water becomes smoke
    // Lava touching water -> this lava becomes obsidian
    if (elem == WATER) {
        bool touchingLava = false;
        for (int dy = -1; dy <= 1; dy++) {
            for (int dx = -1; dx <= 1; dx++) {
                if (getElement(pos + ivec2(dx, dy)) == LAVA) {
                    touchingLava = true;
                }
            }
        }
        if (touchingLava) {
            imageStore(stateOut, pos, uvec4(SMOKE, 200u, 0, 0));
            return;
        }
    }
    if (elem == LAVA) {
        bool touchingWater = false;
        for (int dy = -1; dy <= 1; dy++) {
            for (int dx = -1; dx <= 1; dx++) {
                if (getElement(pos + ivec2(dx, dy)) == WATER) {
                    touchingWater = true;
                }
            }
        }
        if (touchingWater) {
            imageStore(stateOut, pos, uvec4(OBSIDIAN, 0u, 0, 0));
            return;
        }
    }

    // Generic Life Decay (for Gas or decaying elements)
    if (hasLife(elem) && life > 0u) {
        uint decayRate = 4u;
        if (life <= decayRate) {
            // Death transformation - Fire becomes Smoke, others become Empty
            uint deathElem = (elem == FIRE) ? SMOKE : EMPTY;
            uint deathLife = (deathElem == SMOKE) ? 200u : 0u;
            imageStore(stateOut, pos, uvec4(deathElem, deathLife, 0, 0));
            return;
        }
        cur.g = life - decayRate;
    }

    // Flammability Logic (Generic)
    if (isFlammable(elem)) {
        bool touchingFire = false;
        for(int dy = -1; dy <= 1; dy++) {
            for(int dx = -1; dx <= 1; dx++) {
                uint n = getElement(pos + ivec2(dx, dy));
                if (n == FIRE || n == LAVA) touchingFire = true;
            }
        }
        if (touchingFire && random01(pos) < elements[elem].probability) {
            imageStore(stateOut, pos, uvec4(FIRE, 255u, 0, 0));
            return;
        }
    }

    // SEED -> GRASS Logic
    // When a seed lands on dirt (dirt is directly below), it becomes grass with max life
    if (elem == SEED) {
        ivec2 below = pos + ivec2(0, -1);
        if (inBounds(below) && getElement(below) == DIRT) {
            imageStore(stateOut, pos, uvec4(GRASS, 255u, 0, 0));
            return;
        }
    }

    // GRASS Spreading
    // Grass spreads to adjacent dirt cells. The spread probability is proportional
    // to life: high life = more likely to spread. Each new grass gets less life,
    // creating natural diminishing growth outward from the seed point.
    if (elem == GRASS && life > 30u) {
        // Spread chance scales with life: life=255 -> 8% chance, life=30 -> ~1%
        float spreadChance = (float(life) / 255.0) * 0.08;
        if (random01(pos) < spreadChance) {
            // Pick a random cardinal direction
            ivec2 dirs[4] = ivec2[4](ivec2(1,0), ivec2(-1,0), ivec2(0,-1), ivec2(0,1));
            int idx = int(random01(pos + ivec2(int(frameCount), 0)) * 4.0);
            idx = clamp(idx, 0, 3);
            ivec2 target = pos + dirs[idx];

            if (inBounds(target) && getElement(target) == DIRT) {
                // New grass gets less life than parent -> diminishing spread
                uint newLife = life - 25u;
                if (newLife < 30u) newLife = 30u; // Minimum life to still look alive
                imageStore(stateOut, target, uvec4(GRASS, newLife, 0, 0));
            }
        }
    }

    //  MOVEMENT

    // If someone wins moving into us, we get overwritten
    ivec2 winner = pickWinnerForDest(pos);
    if (winner.x != 999999) {
        uvec4 winState = getState(winner);
        imageStore(stateOut, pos, winState);
        return;
    }

    // Otherwise, try to move
    if (!isEmpty(elem) && !isImmobile(elem)) {
        ivec2 dest = desiredDest(pos, elem);
        if (dest != pos && canDisplace(elem, getElement(dest))) {
            ivec2 w = pickWinnerForDest(dest);
            if (w == pos) {
                // We moved. Get what we displaced (swap)
                uvec4 displaced = getState(dest);
                imageStore(stateOut, pos, displaced);
                return;
            }
        }
    }

    // If nothing happened, write back (possibly modified) state
    imageStore(stateOut, pos, cur);
}