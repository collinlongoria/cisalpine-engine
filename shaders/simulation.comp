#version 460 core

layout(local_size_x = 16, local_size_y = 16) in;

layout(rgba8ui, binding = 0) uniform readonly uimage2D stateIn;
layout(rgba8ui, binding = 1) uniform writeonly uimage2D stateOut;

uniform vec2  worldSize;
uniform float time; // randomization seed
uniform uint  frameCount; // deterministic tie-break

uniform float waterViscosity;
uniform float lavaViscosity;

// Element types
const uint EMPTY = 0u;
const uint SAND  = 1u;
const uint STONE = 2u;
const uint WATER = 3u;
const uint LAVA  = 4u;
const uint WOOD  = 5u;
const uint FIRE  = 6u;
const uint SMOKE = 7u;
const uint DIRT  = 8u;
const uint SEED  = 9u;
const uint GRASS = 10u;

// Helpers
bool inBounds(ivec2 p) {
    return (p.x >= 0 && p.x < int(worldSize.x) &&
            p.y >= 0 && p.y < int(worldSize.y));
}

float random01(ivec2 pos) {
    return fract(sin(dot(vec2(pos) + time, vec2(12.9898, 78.233))) * 43758.5453);
}

uint hashU32(uint x) {
    x ^= x >> 16;
    x *= 2246822519u;
    x ^= x >> 13;
    x *= 3266489917u;
    x ^= x >> 16;
    return x;
}
uint hash2u(uvec2 v) {
    return hashU32(v.x ^ (v.y + 0x9e3779b9u + (v.x<<6) + (v.x>>2)));
}

uvec4 getState(ivec2 pos) {
    if (!inBounds(pos)) {
        return uvec4(255u, 0u, 0u, 0u); // solid boundary sentinel
    }
    return imageLoad(stateIn, pos);
}

uint getElement(ivec2 pos) { return getState(pos).r; }
uint getLife(ivec2 pos) { return getState(pos).g; }

// Categories
bool isLiquid(uint e) { return e == WATER || e == LAVA; }
bool isGas(uint e)    { return e == FIRE || e == SMOKE; }
bool isGranular(uint e) { return e == SAND || e == DIRT || e == SEED; }
bool isImmobile(uint e) { return e == STONE || e == WOOD || e == GRASS || e == 255u; }
bool isFlammable(uint e) { return e == WOOD || e == GRASS || e == SEED; }

float viscosityOf(uint e) {
    if (e == WATER) return clamp(waterViscosity, 0.0, 1.0);
    if (e == LAVA)  return clamp(lavaViscosity,  0.0, 1.0);
    return 1.0; // not used
}

bool canDisplace(uint mover, uint target) {
    if (target == EMPTY) return true;
    if (isGas(target)) return true; // Everything displaces gas
    if (mover == LAVA && (target == WATER || isFlammable(target))) return true; // Lava burns things
    if ((isGranular(mover) || mover == LAVA) && target == WATER) return true; // Sink in water
    if (mover == FIRE && target == SMOKE) return true;
    return false;
}

// Movement Logic
ivec2 desiredDest(ivec2 src, uint elem) {
    if (elem == EMPTY || isImmobile(elem)) return src;

    ivec2 down = src + ivec2(0, -1);
    ivec2 downL = src + ivec2(-1, -1);
    ivec2 downR = src + ivec2(1, -1);
    ivec2 left = src + ivec2(-1, 0);
    ivec2 right = src + ivec2(1, 0);
    ivec2 up = src + ivec2(0, 1);
    ivec2 upL = src + ivec2(-1, 1);
    ivec2 upR = src + ivec2(1, 1);

    bool leftFirst = (hash2u(uvec2(src) ^ uvec2(frameCount)) & 1u) == 0u;

    // Granular (Sand, Dirt, Seed)
    if (isGranular(elem)) {
        if (canDisplace(elem, getElement(down))) return down;
        if (leftFirst) {
            if (canDisplace(elem, getElement(downL))) return downL;
            if (canDisplace(elem, getElement(downR))) return downR;
        } else {
            if (canDisplace(elem, getElement(downR))) return downR;
            if (canDisplace(elem, getElement(downL))) return downL;
        }
        return src;
    }

    // Gases (Fire, Smoke) - Rise
    if (isGas(elem)) {
        // Rise up
        if (getElement(up) == EMPTY) return up;

        // Disperse
        if (leftFirst) {
            if (getElement(upL) == EMPTY) return upL;
            if (getElement(upR) == EMPTY) return upR;
            if (getElement(left) == EMPTY) return left;
            if (getElement(right) == EMPTY) return right;
        } else {
            if (getElement(upR) == EMPTY) return upR;
            if (getElement(upL) == EMPTY) return upL;
            if (getElement(right) == EMPTY) return right;
            if (getElement(left) == EMPTY) return left;
        }
        return src;
    }

    // Liquids
    if (isLiquid(elem)) {
        if (canDisplace(elem, getElement(down))) return down;
        float visc = (elem == WATER) ? waterViscosity : lavaViscosity;

        // Viscosity check for spreading
        if (random01(src) < visc) {
             // Only gravity allowed if viscous check fails
             return src;
        }

        if (leftFirst) {
            if (canDisplace(elem, getElement(downL))) return downL;
            if (canDisplace(elem, getElement(downR))) return downR;
            if (canDisplace(elem, getElement(left))) return left;
            if (canDisplace(elem, getElement(right))) return right;
        } else {
            if (canDisplace(elem, getElement(downR))) return downR;
            if (canDisplace(elem, getElement(downL))) return downL;
            if (canDisplace(elem, getElement(right))) return right;
            if (canDisplace(elem, getElement(left))) return left;
        }
    }

    return src;
}

bool sourceProposesTo(ivec2 src, ivec2 dest) {
    if (!inBounds(src)) return false;
    uint e = getElement(src);
    if (e == EMPTY || isImmobile(e)) return false;
    ivec2 d = desiredDest(src, e);
    return (d == dest && canDisplace(e, getElement(dest)));
}

ivec2 pickWinnerForDest(ivec2 dest) {
    ivec2 best = ivec2(999999);
    uint bestScore = 0u;
    bool found = false;

    // Check neighbors
    for (int oy = -1; oy <= 1; ++oy) {
        for (int ox = -1; ox <= 1; ++ox) {
            if (ox == 0 && oy == 0) continue;
            ivec2 src = dest + ivec2(ox, oy);
            if (sourceProposesTo(src, dest)) {
                uint score = hash2u(uvec2(src) ^ uvec2(dest) ^ uvec2(frameCount));
                if (!found || score > bestScore) {
                    found = true;
                    bestScore = score;
                    best = src;
                }
            }
        }
    }
    return found ? best : ivec2(999999);
}

void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    if (!inBounds(pos)) return;

    uvec4 cur = getState(pos);
    uint elem = cur.r;
    uint life = cur.g;

    // --- 1. Elemental Interactions (Reactions) ---
    bool reactionOccurred = false;

    // Fire Logic
    if (elem == FIRE) {
        // Reduce life
        uint fade = 4u + uint(random01(pos) * 5.0); // Random decay
        if (life <= fade) {
            // Die -> become smoke
            imageStore(stateOut, pos, uvec4(SMOKE, 200u, 0u, 0u));
            return;
        }
        cur.g -= fade;
        reactionOccurred = true;

        // Spread fire
        ivec2 dirs[4] = {ivec2(0,1), ivec2(0,-1), ivec2(1,0), ivec2(-1,0)};
        for(int i=0; i<4; i++) {
            ivec2 nPos = pos + dirs[i];
            uint neighbor = getElement(nPos);
            if(isFlammable(neighbor) && random01(pos) < 0.1) {
                // Ignite neighbor (write to stateOut directly? No, this is tricky in parallel)
                // We rely on the neighbor reading US in their update next frame?
                // OR we can't write to neighbor. We must wait for neighbor to check us.
            }
        }
    }

    // Smoke Logic
    if (elem == SMOKE) {
        if (life <= 2u) {
            imageStore(stateOut, pos, uvec4(EMPTY, 0u, 0u, 0u));
            return;
        }
        cur.g -= 2u;
        reactionOccurred = true;
    }

    // Wood/Grass/Seed (Flammable) checking for Fire
    if (isFlammable(elem)) {
        bool touchingFire = false;
        for(int dy=-1; dy<=1; dy++) {
            for(int dx=-1; dx<=1; dx++) {
                if(dx==0 && dy==0) continue;
                uint n = getElement(pos + ivec2(dx, dy));
                if(n == FIRE || n == LAVA) touchingFire = true;
            }
        }
        if (touchingFire) {
            float chance = (elem == WOOD) ? 0.05 : 0.3; // Wood burns slow, grass fast
            if (random01(pos) < chance) {
                // Ignite!
                imageStore(stateOut, pos, uvec4(FIRE, 255u, 0u, 0u));
                return;
            }
        }
    }

    // Seed Logic (Grow Grass)
    if (elem == SEED) {
        // If touching Dirt, turn dirt to Grass
        // Note: We can't change the dirt below us in this pass easily.
        // Instead, if we are ON dirt, we become grass, and rely on spreading logic?
        // Let's say: Seed falls. If it lands on Dirt, it turns ITSELF into Grass.
        ivec2 below = pos + ivec2(0, -1);
        if (getElement(below) == DIRT) {
            imageStore(stateOut, pos, uvec4(GRASS, 0u, 0u, 0u));
            return;
        }
    }

    // Grass Spreading
    if (elem == GRASS) {
        // Randomly spread to nearby Dirt
        if (random01(pos) < 0.005) { // Slow spread
            ivec2 dirs[4] = {ivec2(1,0), ivec2(-1,0), ivec2(0,-1), ivec2(0,1)};
            int idx = int(random01(pos)*4.0);
            ivec2 target = pos + dirs[idx];
            // Since we can't write to neighbor, this is limited.
            // Better: DIRT checks for neighbor GRASS and becomes GRASS.
        }
    }

    // Dirt Logic (Becomes Grass)
    if (elem == DIRT) {
        ivec2 up = pos + ivec2(0, 1);
        // Only grow grass if top is exposed to air (or transparent)
        if (getElement(up) == EMPTY || getElement(up) == WATER) {
            bool touchingGrass = false;
            for(int dx=-1; dx<=1; dx++) {
                uint n = getElement(pos + ivec2(dx, 1)); // Look at diagonals up too
                if (n == GRASS) touchingGrass = true;
            }
            if (touchingGrass && random01(pos) < 0.01) {
                imageStore(stateOut, pos, uvec4(GRASS, 0u, 0u, 0u));
                return;
            }
        }
    }

    // Water/Lava/Stone interactions (Keep existing)
    if (elem == STONE) { /* ... existing ... */ }
    if (elem == WATER) {
        // Lava check
        /* ... existing ... */
    }


    // --- 2. Movement ---

    // If someone wins moving into us, we get overwritten
    ivec2 winner = pickWinnerForDest(pos);
    if (winner.x != 999999) {
        uvec4 winState = getState(winner);
        imageStore(stateOut, pos, winState);
        return;
    }

    // Otherwise, try to move
    if (elem != EMPTY && !isImmobile(elem)) {
        ivec2 dest = desiredDest(pos, elem);
        if (dest != pos && canDisplace(elem, getElement(dest))) {
            ivec2 w = pickWinnerForDest(dest);
            if (w == pos) {
                // We moved. Get what we displaced (swap)
                uvec4 displaced = getState(dest);
                imageStore(stateOut, pos, displaced);
                return;
            }
        }
    }

    // If nothing happened, write back modified state (e.g. reduced fire life)
    imageStore(stateOut, pos, cur);
}